{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c3345e89d91f79d6348ed528e5c46973c3329433",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PythToFairVRFAdapter.sol": "project/contracts/PythToFairVRFAdapter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/FairVRFConsumer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title FairVRFConsumer\n * @notice Abstract contract to make using FairVRF simple.\n * @dev Similar to Chainlink's VRFConsumerBaseV2 for easy migration.\n * @author dev angelo (https://x.com/cryptoangelodev)\n */\nabstract contract FairVRFConsumer {\n    error OnlyCoordinatorCanFulfill(address have, address want);\n\n    address public immutable COORDINATOR;\n\n    /**\n     * @param _coordinator The address of the FairVRF coordinator contract\n     */\n    constructor(address _coordinator) {\n        COORDINATOR = _coordinator;\n    }\n\n    /**\n     * @notice Fulfill randomness handler\n     * @param requestId The ID of the request being fulfilled\n     * @param randomWords The random values generated\n     */\n    function rawFulfillRandomness(uint256 requestId, uint256[] memory randomWords) external {\n        if (msg.sender != COORDINATOR) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, COORDINATOR);\n        }\n        fulfillRandomWords(requestId, randomWords);\n    }\n\n    /**\n     * @notice Callback function to be implemented by the consuming contract\n     * @param requestId The ID of the request being fulfilled\n     * @param randomWords The random values generated\n     */\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n}\n"
      },
      "project/contracts/interfaces/IFairVRF.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n/**\n * @title IFairVRF\n * @dev Interface for FairVRF coordinator\n */\ninterface IFairVRF {\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint64 subId,\n        uint16 requestConfirmations,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) external returns (uint256 requestId);\n    \n    function fulfillRandomness(\n        uint256 requestId,\n        bytes32 nextServerSeed\n    ) external;\n    \n    function currentAnchor() external view returns (bytes32);\n}\n"
      },
      "project/contracts/PythToFairVRFAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"./interfaces/IFairVRF.sol\";\nimport \"./FairVRFConsumer.sol\";\n\n/**\n * @dev Pyth Entropy V2 interface (standalone to avoid external dependencies)\n */\ninterface IEntropyV2 {\n    function requestV2(uint32 callbackGasLimit) external payable returns (uint64);\n    function getFeeV2(uint32 callbackGasLimit) external view returns (uint256);\n}\n\n/**\n * @dev Interface for Entropy consumers (from Pyth SDK)\n */\ninterface IEntropyConsumer {\n    function entropyCallback(\n        uint64 sequenceNumber,\n        address provider,\n        bytes32 randomValue\n    ) external;\n}\n\n/**\n * @title PythToFairVRFAdapter\n * @dev Adapter that makes FairVRF compatible with Pyth Entropy V2 interface\n * This allows existing Pyth-based contracts to use FairVRF with ZERO code changes\n * Just deploy this adapter and point your contract to this address instead of Pyth\n */\ncontract PythToFairVRFAdapter is IEntropyV2, FairVRFConsumer {\n    \n    // State variables\n    mapping(uint256 => uint64) public fairVRFToSequence; // FairVRF requestId => Pyth sequenceNumber\n    mapping(uint64 => uint256) public sequenceToFairVRF; // Pyth sequenceNumber => FairVRF requestId\n    mapping(uint64 => address) public sequenceToConsumer; // sequenceNumber => consumer contract\n    mapping(uint64 => uint32) public sequenceToGasLimit; // sequenceNumber => callback gas limit\n    \n    uint64 private nextSequenceNumber = 1;\n    uint32 private constant DEFAULT_GAS_LIMIT = 500000;\n\n    // Events matching Pyth interface\n    event RandomnessRequested(uint64 indexed sequenceNumber, address indexed consumer);\n\n    constructor(address _fairVRFCoordinator) FairVRFConsumer(_fairVRFCoordinator) {}\n\n    /**\n     * @dev Pyth Entropy V2 requestV2 function - adapted to use FairVRF\n     * @param callbackGasLimit Gas limit for the callback\n     * @return sequenceNumber Unique sequence number for this request\n     */\n    function requestV2(uint32 callbackGasLimit) external payable override returns (uint64) {\n        // Generate sequence number for Pyth compatibility\n        uint64 sequenceNumber = nextSequenceNumber++;\n        \n        // Store consumer info\n        sequenceToConsumer[sequenceNumber] = msg.sender;\n        sequenceToGasLimit[sequenceNumber] = callbackGasLimit;\n        \n        // Make FairVRF request (NO FEES!)\n        uint256 fairVRFRequestId = IFairVRF(COORDINATOR).requestRandomWords(\n            bytes32(0), // keyHash (ignored by FairVRF)\n            0,          // subId (ignored by FairVRF)  \n            3,          // confirmations\n            callbackGasLimit,\n            1           // number of words\n        );\n        \n        // Map the request IDs\n        fairVRFToSequence[fairVRFRequestId] = sequenceNumber;\n        sequenceToFairVRF[sequenceNumber] = fairVRFRequestId;\n        \n        // Refund any ETH sent (FairVRF is free!)\n        if (msg.value > 0) {\n            (bool success, ) = msg.sender.call{value: msg.value}(\"\");\n            require(success, \"Refund failed\");\n        }\n        \n        emit RandomnessRequested(sequenceNumber, msg.sender);\n        return sequenceNumber;\n    }\n\n    /**\n     * @dev FairVRF callback - converts to Pyth format and forwards to consumer\n     */\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        uint64 sequenceNumber = fairVRFToSequence[requestId];\n        address consumer = sequenceToConsumer[sequenceNumber];\n        uint32 gasLimit = sequenceToGasLimit[sequenceNumber];\n        \n        require(consumer != address(0), \"Invalid sequence number\");\n        \n        // For direct requests (consumer is msg.sender), we don't need to call back\n        // For contract consumers, call their entropyCallback\n        if (consumer.code.length > 0) {\n            // Call the consumer's entropyCallback with Pyth interface\n            try IEntropyConsumer(consumer).entropyCallback{gas: gasLimit}(\n                sequenceNumber,\n                address(this), // provider address (this adapter)\n                bytes32(randomWords[0])\n            ) {\n                // Success - clean up\n            } catch {\n                // Handle callback failure gracefully\n                // Could emit an event or implement retry logic\n            }\n        }\n        \n        // Clean up mappings\n        delete fairVRFToSequence[requestId];\n        delete sequenceToFairVRF[sequenceNumber];\n        delete sequenceToConsumer[sequenceNumber];\n        delete sequenceToGasLimit[sequenceNumber];\n    }\n\n    /**\n     * @dev Pyth Entropy V2 getFeeV2 function - returns 0 since FairVRF is free\n     * @param callbackGasLimit Gas limit (ignored)\n     * @return Always returns 0 (FairVRF has no fees!)\n     */\n    function getFeeV2(uint32 callbackGasLimit) external pure override returns (uint256) {\n        callbackGasLimit; // Silence unused parameter warning\n        return 0; // FairVRF is completely free!\n    }\n\n    /**\n     * @dev Emergency function to withdraw any accidentally sent ETH\n     */\n    function withdraw() external {\n        require(msg.sender == owner(), \"Only owner\");\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @dev Get the owner (for withdraw function)\n     */\n    function owner() public pure returns (address) {\n        // You can implement proper ownership or use OpenZeppelin's Ownable\n        // For now, return zero address to disable withdraw\n        return address(0); // TODO: Implement proper ownership\n    }\n\n    /**\n     * @dev Receive function to handle accidental ETH transfers\n     */\n    receive() external payable {\n        // Accept ETH and refund immediately since FairVRF is free\n        if (msg.value > 0) {\n            (bool success, ) = msg.sender.call{value: msg.value}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n}\n"
      }
    }
  }
}